import "core-js/es/array/at";
import {
  attribute,
  hashKey,
  autoGeneratedHashKey,
  rangeKey,
  table,
} from "@aws/dynamodb-data-mapper-annotations";

import * as utils from "../utils";
import { CardEffectBase, MatchEventBase, MatchEnded } from "./model";
import Player from "./player";
import Move from "./move";
import MatchState from "./matchstate";

export type MatchId = string;

@table("Matches")
export default class Match {
  @autoGeneratedHashKey()
  id?: MatchId;

  @attribute()
  players: Player[];

  //-- do not directly save moves, should be persisted on creation and last on should be retrieved upon db read
  move: Move;

  // @attribute({
  //   //-- when using "S" field - longer, but easier to perceive
  //   marshall: utils.dateMarshall,
  //   unmarshall: utils.dateUnmarshall,
  //   defaultProvider: () => new Date().toISOString(),
  // })
  @rangeKey({
    //-- when using "N" field
    type: "Date",
    defaultProvider: () => new Date(),
  })
  startedAt!: Date;

  constructor(players?: Array<Player>) {
    this.players = players;
  }
  get numberOfPlayers(): number {
    return this.players?.length;
  }
  get state(): MatchState {
    //-- it might happen that this ha sno state, check for the previous one
    //return this.lastMove?.state ?? this.moves?.at(-2)?.state; //TO-CHECK, -2 is really needed?
    return this.move?.state;
    //TODO: consider move having a state at the very beginning...
  }
  get lastEvent(): MatchEventBase {
    return this.move?.lastEvent;
  }
  get currentPlayer(): Player {
    return this.players[this.move?.currentPlayerIndex];
  }
  get pendingEffect(): CardEffectBase {
    return this.state?.pendingEffect;
  }
  get isFinished(): boolean {
    return this.move?.lastEvent instanceof MatchEnded;
  }
}
