/* tslint:disable:max-classes-per-file */
import "core-js/es/array/at";
import {
  attribute,
  hashKey,
  autoGeneratedHashKey,
  rangeKey,
  table,
} from "@aws/dynamodb-data-mapper-annotations";
import { embed } from "@aws/dynamodb-data-mapper";

import MatchState from "./matchstate";
import Player, { PlayerId } from "./player";
import { Card } from "./model";
import { CardEffectBase } from "./cardeffect";

export const OMatchEventType = {
  MatchStarted: 0,
  TurnStarted: 1,
  Draw: 2,
  CardPlayedEffect: 3,
  ResponseToEffect: 4,
  CardPlacedToPlayArea: 5,
  CardRemovedFromBank: 6,
  EndTurn: 7,
  TurnEnded: 8,
  MatchEnded: 9,
  // QueryDrawPile: 10,
  // QueryDiscardPile: 11,
  // QueryMatchStatus: 12,
} as const;
export type MatchEventType = keyof typeof OMatchEventType;

export class MatchEventBase {
  @attribute()
  eventType: MatchEventType = undefined;

  @attribute(embed(MatchState))
  state: MatchState;

  get currentPlayerIndex(): number {
    return this.state.currentPlayerIndex;
  }
}
export class MatchAction extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = undefined;

  get actionVerb(): string {
    return this.eventType;
  }
}

export class MatchStarted extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "MatchStarted";
}
export class TurnStarted extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "TurnStarted";

  @attribute()
  player: PlayerId;

  constructor(player: PlayerId) {
    super();
    this.player = player;
  }
}
export class Draw extends MatchAction {
  @attribute()
  readonly eventType: MatchEventType = "Draw";

  @attribute()
  readonly card: Card;

  constructor(card: Card) {
    super();
    this.card = card;
  }
}
export class CardPlacedToPlayArea extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "CardPlacedToPlayArea";

  @attribute()
  readonly card: Card;

  @attribute()
  readonly direction: boolean;

  constructor(card: Card, direction: boolean = true) {
    super();
    this.card = card;
  }
}
export class CardPlayedEffect extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "CardPlayedEffect";
  @attribute()
  readonly effect: CardEffectBase;

  constructor(effect: CardEffectBase) {
    super();
    this.effect = effect;
  }
}
export class TurnEnded extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "TurnEnded";

  @attribute({ memberType: embed(Card) })
  readonly cardsCollected: Array<Card>;

  @attribute()
  readonly isSuccessful: boolean;

  constructor(isSuccessful: boolean, cardsCollected: Array<Card>) {
    super();
    this.isSuccessful = isSuccessful;
    this.cardsCollected = cardsCollected;
  }
}
export class EndTurn extends MatchAction {
  @attribute()
  readonly eventType: MatchEventType = "EndTurn";
}
export class MatchEnded extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "MatchEnded";

  @attribute({ memberType: embed(Number) })
  scores: Array<number>;

  @attribute()
  winner: Player;
}
export class CardRemovedFromBank extends MatchEventBase {
  @attribute()
  readonly eventType: MatchEventType = "CardRemovedFromBank";

  @attribute()
  readonly card: Card;

  @attribute()
  readonly playerIndex: number;

  constructor(card: Card, playerIndex: number) {
    super();
    this.card = card;
    this.playerIndex = playerIndex;
  }
}

//====
export class ResponseToEffect extends MatchAction {
  @attribute()
  readonly eventType: MatchEventType = "ResponseToEffect";

  @attribute()
  readonly name: string;

  @attribute()
  readonly card: Card;

  constructor(name: string, card: Card) {
    super();
    this.name = name;
    //LATER: e.g.cannon/sword - in case of multiplayer player is not (directly) covered -- card determines though
    this.card = card;
  }
}
