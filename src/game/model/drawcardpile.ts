import "core-js/es/array/at";
import { Card, CardPile, OCardSuit, CardSuit } from "./model";
import {
  attribute,
  hashKey,
  autoGeneratedHashKey,
  rangeKey,
  table,
} from "@aws/dynamodb-data-mapper-annotations";

/**
 * Draw card pile - contains all remining cards
 */
export default class DrawCardPile extends CardPile {
  populate(pojo: any) {
    super.populate(pojo);
    if (pojo.hasOwnProperty("isPreOrdered")) this.isPreOrdered = pojo?.isPreOrdered;
    if (pojo.hasOwnProperty("nextCard")) this.nextCard = new Card().populate(pojo.nextCard);
    return this;
  }

  @attribute()
  nextCard?: Card; //-- Oracle reveals Next Card

  @attribute()
  isPreOrdered: boolean; //-- debug purposes preset order, without random draw

  public static create(): DrawCardPile;
  public static create(cards: Array<Card | any>): DrawCardPile;
  public static create(suits: Array<CardSuit>, values: Array<number>): DrawCardPile; //CardValue
  public static create(cardsOrSuits?: Array<any>, values?: Array<number>): DrawCardPile {
    //CardValue
    let retval = new DrawCardPile();

    if (cardsOrSuits instanceof Array) {
      //-- list of cards or card abbreviations
      cardsOrSuits.forEach((cardobj) => {
        if (cardobj instanceof Card) retval.cards.push(cardobj);
        else retval.cards.push(new Card().populate(cardobj));
      });
      retval.isPreOrdered = true;
    }
    if (retval.cards.length == 0) {
      //-- default stack or generated suit/values
      retval.isPreOrdered = false;
      if (!cardsOrSuits) {
        cardsOrSuits = Object.keys(OCardSuit) as CardSuit[]; //-- empty suits --> use all suits
        if (!values) values = [2, 3, 4, 5, 6, 7]; //-- empty values --> use default 2-7 values
      } else if (!values) {
        throw new Error("Invalid values");
      }

      //-- generate cards
      for (let s of cardsOrSuits) {
        for (let cv of values) {
          const cv2 = cv + (s == "Mermaid" ? +2 : 0); // as CardValue; //-- for Mermaid shift 2-7 to 4-9
          const card = new Card(s, cv2);
          retval.cards.push(card);
        }
      }
    }

    //-- return generated pile
    return retval;
  }

  public draw(doRemoveFromPile: boolean = true): Card | undefined {
    let pickedCardindex = -1;

    //-- check if pending (peeked card) draw due to oracle
    if (this.nextCard) {
      let pickedCardindex = this.cards.findIndex(
        (c) => c.suit === this.nextCard?.suit && c.value === this.nextCard?.value
      );

      delete this.nextCard; //-- reset peeked card

      //-- we need to remove the card from the pile as well - as peeking does not remove it
      let pickedCard = this.cards.splice(pickedCardindex, 1)?.at(0);
      return pickedCard;
    }

    //-- if this is preordered, use next card
    if (this.isPreOrdered)
      return doRemoveFromPile ? this.cards.splice(0, 1)?.at(0) : this?.cards.at(0);

    //-- default case - pick a random card
    //-- execute the draw
    pickedCardindex = Math.floor(Math.random() * this.cards.length);
    return doRemoveFromPile
      ? this.cards.splice(pickedCardindex, 1)?.at(0)
      : this?.cards.at(pickedCardindex);
  }
} // or Map<Suit, number>; -- but how to do random?
