import "core-js/es/array/at";
/* tslint:disable:max-classes-per-file */
import {
  attribute,
  hashKey,
  autoGeneratedHashKey,
  rangeKey,
  table,
} from "@aws/dynamodb-data-mapper-annotations";
import { embed } from "@aws/dynamodb-data-mapper";

export interface SupportsHydration {
  populate(pojo: any): any;
}

export const OCardSuit = {
  Anchor: "Anchor",
  Hook: "Hook",
  Cannon: "Cannon",
  Key: "Key",
  Chest: "Chest",
  Map: "Map",
  Oracle: "Oracle",
  Sword: "Sword",
  Kraken: "Kraken",
  Mermaid: "Mermaid",
}; // as const;
export type CardSuit = keyof typeof OCardSuit;
export function IsCardSuit(cardSuit?: string): cardSuit is CardSuit {
  return !!cardSuit;
}
// export type Suit = typeof OSuit[keyof typeof OSuit];
// export type Suit =
//   | "Anchor"
//   | "Hook"
//   | "Cannon"
//   | "Key"
//   | "Chest"
//   | "Map"
//   | "Oracle"
//   | "Sword"
//   | "Kraken"
//   | "Mermaid";

/**
 * Card abbreviation
 */
//export type CardValueBase = 2 | 3 | 4 | 5 | 6 | 7;
//export type CardValue = CardValueBase | 8 | 9;
//export type CardAbbreviation = [CardSuit, number]; //CardValue];

/**
 * Card object
 */
export class Card implements SupportsHydration {
  populate(pojo: any): any {
    if (pojo.hasOwnProperty("suit") && pojo.hasOwnProperty("value")) {
      //-- full form: {"suit":"Kraken", "value":4}
      this.suit = pojo.suit;
      this.value = pojo.value;
    } else if (
      Array.isArray(pojo) &&
      pojo.length == 2 &&
      IsCardSuit(pojo[0]) &&
      typeof pojo[1] === "number"
    ) {
      //-- tuple form: ["Kraken",4]
      this.suit = pojo[0];
      this.value = pojo[1];
    } else {
      //-- abbreviated form: {"Kraken":4}, one card per object
      const asuitvalue = Object.keys(OCardSuit).find(
        (asuit) =>
          pojo.hasOwnProperty(asuit) &&
          IsCardSuit(asuit) &&
          typeof pojo[asuit] == "number"
      ) as CardSuit;
      if (asuitvalue) {
        this.suit = asuitvalue;
        this.value = pojo[asuitvalue];
      } else throw new Error("Invalid Card");
    }
    return this;
  }

  @attribute()
  suit?: CardSuit;

  @attribute({ unwrapNumbers: true }) //{ memberType: "Number" }
  value?: number; //CardValue;

  //-- override toJSON
  toJSON() {
    return [this.suit, this.value];
  }
  toBSON() {
    return this.toJSON();
  }

  constructor(suit?: CardSuit, value?: number) {
    //CardValue) {
    this.suit = suit;
    this.value = value;
    if (
      suit !== undefined &&
      value !== undefined &&
      !(suit !== OCardSuit.Mermaid && value >= 2 && value <= 7) &&
      !(suit === OCardSuit.Mermaid && value >= 4 && value <= 9)
    )
      throw new Error("Invalid Card");
  }
}

/**
 * Card pile object
 */
export class CardPile implements SupportsHydration {
  populate(pojo: any) {
    let pojoiter = pojo?.hasOwnProperty("cards") ? pojo.cards : pojo;
    if (Array.isArray(pojoiter))
      this.cards = pojoiter?.map((cardpojo: any) =>
        new Card().populate(cardpojo)
      );
    return this;
  }

  /*readonly*/
  cards: Array<Card>;
  //-- architecture warning - should not derive from Array<Card> directly as lodash Lodash only clones index values (and some meta values) of arrays.
  //-- architecture warning - should not override toJSON to default as for DrawCardPile we will need a cards + properties separately in the storage structure

  constructor() {
    this.cards = new Array<Card>();
  }
  get length(): number {
    return this.cards.length;
  }
  set length(value: number) {
    this.cards.length = value;
  }
}
/**
 * Card suit stack - for effective representation of bank collection ordered by suits
 */
export class CardSuitStack implements SupportsHydration {
  populate(pojo: any) {
    // this.stack.splice(0, Infinity);
    this.stack.clear();

    const pojoiter = pojo.stack || pojo;
    if (Array.isArray(pojoiter))
      pojoiter?.forEach((pojo: any) => this.add(pojo));
    return this;
  }

  stack: Set<number>; //Array<number>; //CardValue //Set<number>

  //-- override toJSON
  //-- architectural: it is ok from architectural prespective as de do not have any other subproperties
  toJSON() {
    //return this.stack;
    //-- attention: default serialization cannot handle Set<>
    return [...this.stack];
  }
  toBSON() {
    return this.toJSON();
  }

  add(value: number) {
    // const idx = this.stack.indexOf(value);
    // if (idx >= 0)
    //   throw new Error("Cannot add " + value + " to stack - already exists.");

    // this.stack.push(value);
    this.stack.add(value);
  }
  delete(value: number) {
    // const idx = this.stack.indexOf(value);
    // if (idx < 0) throw new Error("Cannot remove " + value + " from stack.");
    // this.stack.splice(idx, 1);
    this.stack.delete(value);
  }
  get size() {
    // return this.stack.length;
    return this.stack.size;
  }

  constructor() {
    //this.stack = new Array<number>(); //CardValue>();
    this.stack = new Set<number>(); //CardValue>();
  }

  max() {
    return Math.max.apply(null, Array.from(this.stack.values()));
  }
}
/**
 * Ordered card pile - for effective representation of bank collection ordered by suits
 */
export class OrderedCardPile {
  populate(pojo: any) {
    this.piles.clear();

    const pojoiter = pojo.piles || pojo;
    if (pojoiter)
      Object.getOwnPropertyNames(pojoiter).forEach((k: any, v: any, arr: any) =>
        this.piles.set(k, new CardSuitStack().populate(pojoiter[k]))
      );
    return this;
  }

  constructor() {
    this.piles = new Map<CardSuit, CardSuitStack>();
  }

  piles: Map<CardSuit, CardSuitStack>;

  //-- override toJSON
  //-- architectural: it is ok from architectural prespective as de do not have any other subproperties
  toJSON() {
    //-- attention: default serialization cannot handle Map<>
    return Object.fromEntries(this.piles);
  }
  toBSON() {
    return this.toJSON();
  }

  get flatSize(): number {
    let count = 0;
    for (let [key, value] of this.piles.entries()) count += value.size;
    return count;
  }
}

/**
 * FlatCardPile - with no properties
 */
export class FlatCardPile extends CardPile {
  //-- override toJSON
  //-- architectural: it is ok from architectural prespective as de do not have any other subproperties
  toJSON() {
    return this.cards;
  }
  toBSON() {
    return this.toJSON();
  }
}

/**
 * Bank - object for a player's bank
 */
export class Bank extends OrderedCardPile {}

/**
 * Play area - object to represent the play area
 */
export class PlayArea extends FlatCardPile {} // or Map<Suit, number>;

export { default as DrawCardPile } from "./drawcardpile";
export { default as MatchState } from "./matchstate";
export { default as Match, MatchId } from "./match";
export { default as Move, MoveId } from "./move";
export { default as Player, PlayerId } from "./player";
export * from "./matchevent";
export * from "./cardeffect";
export * from "./utils";
