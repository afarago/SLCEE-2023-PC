import "core-js/es/array/at";
import {
  attribute,
  hashKey,
  autoGeneratedHashKey,
  rangeKey,
  table,
} from "@aws/dynamodb-data-mapper-annotations";

import { CardEffect, MatchEvent, OMatchEventType } from "./model";
import Player from "./player";
import Move from "./move";
import MatchState from "./matchstate";

export type MatchId = string;

@table("Matches")
export default class Match {
  @autoGeneratedHashKey()
  id?: MatchId;

  @attribute()
  players: Player[];

  //-- do not directly save moves, should be persisted on creation and last on should be retrieved upon db read
  move: Move;

  // @attribute({
  //   //-- when using "S" field - longer, but easier to perceive
  //   marshall: utils.dateMarshall,
  //   unmarshall: utils.dateUnmarshall,
  //   defaultProvider: () => new Date().toISOString(),
  // })
  @rangeKey({
    //-- when using "N" field
    type: "Date",
    defaultProvider: () => new Date(),
  })
  startedAt!: Date;

  constructor(players?: Array<Player>) {
    this.players = players;
  }
  get numberOfPlayers(): number {
    return this.players?.length;
  }
  get state(): MatchState {
    return this.move?.state;
  }
  get lastEvent(): MatchEvent {
    return this.move?.lastEvent;
  }
  get currentPlayer(): Player {
    return this.players[this.move?.currentPlayerIndex];
  }
  get pendingEffect(): CardEffect {
    return this.state?.pendingEffect;
  }
  get isFinished(): boolean {
    return this.move?.lastEvent.eventType === OMatchEventType.MatchEnded;
  }
}
